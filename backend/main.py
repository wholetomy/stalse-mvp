# backend/main.py
import sqlite3
import json
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from pathlib import Path
import requests
import os

BASE_DIR = Path(__file__).parent  # pasta onde est√° main.py

DB_PATH = BASE_DIR / "db.sqlite"
DATA_METRICS = Path("/app/data/processed/metrics.json")
SEEDS_PATH = BASE_DIR / "seeds/seeds.json"

app = FastAPI(title="API")

origins = [
    "http://localhost:3000",
    "http://127.0.0.1:3000",
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

class PatchBody(BaseModel):
    status: str | None = None
    priority: str | None = None

def get_conn():
    conn = sqlite3.connect(DB_PATH)
    conn.row_factory = sqlite3.Row
    return conn

def create_tables():
    conn = get_conn()
    cur = conn.cursor()
    cur.execute("""
    CREATE TABLE IF NOT EXISTS tickets (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        created_at TEXT,
        customer_name TEXT,
        channel TEXT,
        subject TEXT,
        status TEXT,
        priority TEXT,
        metadata TEXT
    )
    """)
    conn.commit()
    conn.close()

def load_seeds_if_empty():
    conn = get_conn()
    cur = conn.cursor()
    cur.execute("SELECT COUNT(1) as c FROM tickets")
    count = cur.fetchone()["c"]
    if count == 0:
        if SEEDS_PATH.exists():
            with open(SEEDS_PATH, "r", encoding="utf-8") as f:
                seeds = json.load(f)
        else:
            # minimal autogenerated seeds if file missing
            seeds = []
            from datetime import datetime, timedelta
            for i in range(1, 21):
                seeds.append({
                    "created_at": (datetime.utcnow() - timedelta(days=i%5)).isoformat(),
                    "customer_name": f"Customer {i}",
                    "channel": "email" if i%2==0 else "chat",
                    "subject": f"Subject {i}",
                    "status": "open" if i%3!=0 else "closed",
                    "priority": "low" if i%4==0 else "normal",
                    "metadata": {}
                })
        for s in seeds:
            cur.execute("""
            INSERT INTO tickets (created_at, customer_name, channel, subject, status, priority, metadata)
            VALUES (?, ?, ?, ?, ?, ?, ?)
            """, (s.get("created_at"), s.get("customer_name"), s.get("channel"), s.get("subject"),
                  s.get("status"), s.get("priority"), json.dumps(s.get("metadata", {}))))
        conn.commit()
    conn.close()

@app.on_event("startup")
def startup():
    create_tables()
    load_seeds_if_empty()

@app.get("/tickets")
def list_tickets(q: str | None = None, status: str | None = None, page: int = 1, per_page: int = 100):
    conn = get_conn()
    cur = conn.cursor()
    query = "SELECT * FROM tickets"
    params = []
    where = []
    if q:
        where.append("(customer_name LIKE ? OR subject LIKE ?)")
        params.extend([f"%{q}%", f"%{q}%"])
    if status:
        where.append("status = ?")
        params.append(status)
    if where:
        query += " WHERE " + " AND ".join(where)
    query += " ORDER BY created_at DESC"
    # pagination
    offset = (page - 1) * per_page
    query += f" LIMIT {per_page} OFFSET {offset}"
    cur.execute(query, params)
    rows = [dict(r) for r in cur.fetchall()]
    conn.close()
    return rows

@app.get("/tickets/{ticket_id}")
def get_ticket(ticket_id: int):
    conn = get_conn()
    cur = conn.cursor()
    cur.execute("SELECT * FROM tickets WHERE id = ?", (ticket_id,))
    r = cur.fetchone()
    conn.close()
    if not r:
        raise HTTPException(status_code=404, detail="Ticket not found")
    return dict(r)

@app.patch("/tickets/{ticket_id}")
def patch_ticket(ticket_id: int, body: PatchBody):
    conn = get_conn()
    cur = conn.cursor()
    cur.execute("SELECT * FROM tickets WHERE id = ?", (ticket_id,))
    r = cur.fetchone()
    if not r:
        conn.close()
        raise HTTPException(status_code=404, detail="Ticket not found")
    updates = {}
    if body.status is not None:
        updates["status"] = body.status
    if body.priority is not None:
        updates["priority"] = body.priority
    if not updates:
        conn.close()
        return {"ok": True}
    set_clause = ", ".join([f"{k} = ?" for k in updates.keys()])
    params = list(updates.values()) + [ticket_id]
    cur.execute(f"UPDATE tickets SET {set_clause} WHERE id = ?", params)
    conn.commit()
    # after update, optionally call webhook if rules match
    if ("status" in updates and updates["status"] == "closed") or ("priority" in updates and updates["priority"] == "high"):
        try:
            webhook_url = os.environ.get("N8N_WEBHOOK_URL")
            if webhook_url:
                payload = {
                    "ticket_id": ticket_id,
                    "status": updates.get("status"),
                    "priority": updates.get("priority")
                }
                requests.post(webhook_url, json=payload, timeout=2)
        except Exception as ex:
            # non-blocking: log but don't fail
            print("webhook error:", ex)
    conn.close()
    return {"ok": True}

@app.get("/metrics")
def metrics():
    if DATA_METRICS.exists():
        return json.loads(DATA_METRICS.read_text(encoding="utf-8"))
    else:
        raise HTTPException(status_code=404, detail="metrics not found; run ETL")